export { default as theme } from './theme.js';
import dracula from "prism-react-renderer/themes/dracula"
import { Head, Appear, Image } from 'mdx-deck';
import Drake from './components/drake.js';
import Dawg from './components/yoDawg.js';
import Small from './components/Small.js';
import Gru from './components/gru.js';
import { FullScreenCode } from 'mdx-deck/layouts'
import { CodeSurfer } from "mdx-deck-code-surfer"
import butWhy from './images/but-why.gif'
import composition1 from './images/composition1.png'
import composition2 from './images/composition2.png'
import Fugue from './components/music/examples/fugue.js'
import MiddleC from './components/music/examples/middleC.js'
import Filters from './components/music/examples/filterExample.js'
import Map from './components/music/examples/mapExample.js'
import Detuned from './components/music/examples/detune.js'
import Wow from './components/music/examples/wowTest.js'

<Head>
  <title>Composing music with composed functions</title>
  <style>@import url('https://fonts.googleapis.com/css?family=Anton')</style>
</Head>

# Composing music with <br />composed functions
### Adam Giese (@AdamGieseDev)

```notes
Give a brief introduction

- Welcome to '____'
- My name is Adam Giese
- Software engineer full time for five years
- Before that, attended school for music
- Drawn to music theory -- analytical thinking
- When started FP, found same itch scratched
- When started musical project, decided FP

"So, here is my introduction to functional programming — from a musical perspective."
```

---

## What is functional programming?

<Appear>
  Programming with functions!
</Appear>

```notes
- What is functional programming?

- (short pause -- click through)

- It's programming with functions!

- Object oriented based around objects

- 'Functions' are the building block
```

---

## What is a function?
<Drake
  top1={'A sequence of commands'}
  top2={'abstracted into a reusable unit.'}
  bottom1={'A relationship between a'}
  bottom2={'set of inputs and outputs.'}
/>

---

### 'Pure' functions

<Appear>
  <div>1. Given the same arguments, it will return the same value.</div>
  <div>2. No side effects.</div>
  <div><hr />This makes a function "referentially transparent."</div>
</Appear>

```notes
- The ONLY thing you should care about is the return value
```
---

<Gru />

---

## Side effects are *NOT* bad. They include:
- Making an HTTP request
- DOM manipulation
- Printing to the console
- Playing music
---

<CodeSurfer
  code={require("!raw-loader!./snippets/pure-vs-impure.js")}
  lang="javascript"
  showNumbers={false}
  dark={true}
  steps={[
      { range: [1,4], notes: "Define a musical note with name and octave" },
      { lines: [6,7], notes: "`incrementOctave` is a pure function" },
      { range: [9,11], notes: "`play` is an impure function, because it has a side effect" },
      { range: [10,11], notes: "You can pass in either `highC` or `incrementOctave(middleC)` and have the same effect" },
      { range: [10,11], notes: "This is due to 'referential transparency'" },
  ]}
/>

---
# Immutability
<Small>definition: a variable whose state cannot be modified after creation</Small>
---
<Image src={butWhy} size='60vw' />
---

## Immutability preserves state

> "If you have a dollar, and I give you another dollar, it does not change the fact that a moment ago you only had one dollar, and now you have two."
_-Eric Elliott_

```notes
- Data is preserved.
- Think about a bank account?
- Redux architecture
- Musical score
- Philisophically, think about TIME itself
```
---
## Easier to reason about
- Prevents unintentional side effects
- No need to keep track of changes
- Declarative
---

## Math is immutable
```js
let x = 10;
x = x + 1;       // nonsense
const y = x + 1; // much better
```

---

# Higher order functions

<Small>definition: a function that either accepts a function <br />as an argument or returns a new function</Small>

---
<Dawg
  line1='Yo dawg I heard you like functions so I made a function'
  line2='that takes a function and returns a function'
>
</Dawg>
---
<CodeSurfer
  code={require("!raw-loader!./snippets/returnFunction.js")}
  lang="javascript"
  showNumbers={false}
  dark={true}
  steps={[
      {},
      { range: [1,2], notes: "Tone.js is a framework on top of the Web Audio API" },
      { range: [4,4], notes: "`playNote` is a higher order function because it returns another function." },
      { range: [5,5], notes: "`playMiddleC` is the return value of `playNote('C4')`" },
      { range: [5,5], notes: "No note has been played yet!" },
      { range: [7,8], notes: "`playMiddleC` is called when the button is clicked" },
      { range: [8,8], notes: "`addEventListener` is a higher order function because it accepts a function." },
  ]}
/>

---

<MiddleC />

---
# Dealing with arrays

```notes
- Manipulating arrays is an important part of all paradigms

- Two concepts that we already covered that are important:
  -- Higher order functions
  -- Immutability
```
---
## `[].filter`
- Accepts a function run again every element
- <code>predicate(element, index, array)</code>
- Returns a subset of the original array
---
<CodeSurfer
  code={require("!raw-loader!./snippets/filter.js")}
  lang="javascript"
  showNumbers={false}
  dark={true}
  steps={[
      {},
      { range: [1,1], notes: "Import Tone.js" },
      { range: [2,4], notes: "Define the melody" },
      { range: [6,6], notes: "`freq` converts from string ('A4') to number (440)" },
      { range: [7,7], notes: "`isHigh` is a 'predicate' (a function that returns a boolean)" },
      { range: [7,7], notes: "If the provided note is 'C4' or above it will return true" },
      { range: [9,9], notes: "`.filter` accepts a predicate as its argument" },
      { range: [10,10], notes: "Any values that pass the predicate remain" },
  ]}
/>
---

<Filters />

---
## `[].map`
- Accepts a function run again every element
- <code>fn(element, index, array)</code>
- Returns new array with manipulated values

---
<CodeSurfer
  code={require("!raw-loader!./snippets/map.js")}
  lang="javascript"
  showNumbers={false}
  dark={true}
  steps={[
      {},
      { range: [9,9], notes: "This function takes a 'note' object and returns one with an incremented octave" },
      { range: [11,11], notes: "The `.map` method accepts a function that is applied to each array element" },
      { range: [13,18], notes: "In the new array, each note's octave has been incremented" },
  ]}
/>
---

<Map />

---
## `[].reduce`
- Accepts a function run again every element
- <code>fn(accumulator, element, index, array)</code>
- Returns an 'accumulated' value
- Also known as 'fold' and 'accumulate'
- More generic than 'filter' and 'map'
---
<CodeSurfer
  code={require("!raw-loader!./snippets/reduce.js")}
  lang="javascript"
  showNumbers={false}
  dark={true}
  steps={[
      {},
      { range: [1,1], notes: "First, import Tone.js" },
      { range: [3,17], notes: "Define a melody with note names and length" },
      { range: [19,20], notes: "`toLength` is the function being passed to reduce" },
      { range: [19,20], notes: "It adds a notes length to a running total" },
      { range: [22,22], notes: "The method accepts a function and an initial value" },
      { range: [23,23], notes: "The return value is the end 'accumulation'" },
  ]}
/>

```notes
- I often here that `.reduce` takes an array and returns a single value
- While this is true, it isn't super useful (since ALL functions return a single value)
- It is a very generic utility function that can return any type
```
---

## Closure
<Small>definition: a function and its access to its enclosed state</Small>
---
### Partial Application
<Small>definition: a technique to "pre-set" some arguments of a function</Small>

```notes
- an application of closure
- incredibly useful for writing reusable, generic functions
```
---
<CodeSurfer
  code={require("!raw-loader!./snippets/closure.js")}
  lang="javascript"
  showNumbers={false}
  dark={true}
  steps={[
      {},
      { range: [1,5], notes: "Closure allows an inner function to 'remember' its enclosing scope." },
      { range: [7,8], notes: "With ES6 arrow functions, you can write very concise examples of closure" },
      { range: [10,13], notes: "With partial application, you can set the array before the value" },
      { range: [15,18], notes: "" },
  ]}
/>
---

## Composition
<Small>definition: a technique to combine multiple functions into a new function</Small>

```notes
- I like the metaphor of "pipes"
```
---

<img src={composition1} />

---

<img src={composition2} />

---

<CodeSurfer
  code={require("!raw-loader!./snippets/simpleComposition.js")}
  lang="javascript"
  showNumbers={false}
  dark={true}
  steps={[
      { range: [1,16], notes: "Here, we will take a note name and return a slightly detuned frequency."},
      { range: [3,4], notes: "First, define a function converting note name to frequency" },
      { range: [3,4], notes: "For example: an input of 'A4' would return 440" },
      { range: [6,7], notes: "Define a function to multiply by a small percentage" },
      { range: [6,7], notes: "For example: an input of 440 would return 444.4" },
      { range: [9,10], notes: "These are two similar functions" },
      { range: [9,9], notes: "`compose` takes two functions and calls from right to left" },
      { range: [9,9], notes: "This is the more 'mathematical' approach" },
      { range: [10,10], notes: "`pipe` takes two functions and calls from left to right" },
      { range: [12,13], notes: "`getDetunedFrequency` is the composition of these functions" },
      { range: [12,13], notes: "An input of 'A4' would return 444.4" },
      { range: [15,16], notes: "The same result can be achieved with a `pipe`" },
  ]}
/>

---

<Detuned />

---

# Putting it all together

---

<CodeSurfer
  code={require("!raw-loader!./components/music/util/parseShorthand.js")}
  lang="javascript"
  showNumbers={false}
  dark={true}
  steps={[
      {},
      { range: [1,15], notes: "Importing some dependencies from Ramda and Tonejs."},
      {},
      { range: [17,20], notes: "`parseName` takes a shorthand note and returns a name"},
      { range: [17,20], notes: "For example, 'C4@8n' would return 'C'"},
      { range: [17,20], notes: "It pipes the input through two other functions:"},
      { range: [18,18], notes: "First, use `match` to return an array of matching strings"},
      { range: [19,19], notes: "Then, use `head` to return just the first string"},
      { range: [17,20], notes: "So, when passing a 'C4@8n'..."},
      { range: [18,18], notes: "The `match` function returns ['C']..."},
      { range: [18,18], notes: "...then the `head` function takes that ['C'] and returns 'C'."},
      { range: [17,20], notes: "'C4@8n' → ['C'] → 'C'"},
      {},
      { range: [22,25], notes: "`parseOctave` takes a shorthand note and returns an octave"},
      { range: [22,25], notes: "For example, 'C4@8n' would return 4"},
      { range: [23,23], notes: "`match` returns an array of strings of matching digits"},
      { range: [24,24], notes: "Use `Number` to coerce this array to a Number."},
      { range: [22,25], notes: "'C4@8n' → ['4'] → 4"},
      {},
      { range: [27,30], notes: "`parseDuration` takes a shorthand note and returns a duration"},
      { range: [27,30], notes: "For example, 'C4@8n' would return '8n'"},
      { range: [28,28], notes: "`split` returns an array of strings separated at '@'"},
      { range: [29,29], notes: "`last` returns the last element of this array"},
      { range: [27,30], notes: "'C4@8n' → ['C4', '8n'] → '8n'"},
      {},
      { range: [32,35], notes: "`parseTime` takes a note and its context..."},
      { range: [32,35], notes: "...and returns a scheduled time"},
      { range: [33,33], notes: "The array is sliced to only include preceding notes."},
      { range: [34,34], notes: "Each remaining element will be mapped to its length in seconds"},
      { range: [35,35], notes: "This array of times are reduced to their total length"},
      { range: [32,32], notes: "('E4@8n', 2, ['C4@8n.','D4@16n','E4@8n','F4@8n']) →"},
      { range: [33,33], notes: "['C4@8n.','D4@16n'] →"},
      { range: [34,34], notes: "[.375,.125] →"},
      { range: [35,35], notes: ".5"},
      {},
      { range: [37,37], notes: "`addIndex(map)` makes Ramda map more like the array method."},
      { range: [38,49], notes: "`parseShorthand` is a composition of compositions!"},
      { range: [38,49], notes: "It accepts a string and returns an array of objects"},
      { range: [39,39], notes: "First, it splits at all whitespace. String→Array"},
      { range: [40,47], notes: "`arrayMap` works like [].map"},
      { range: [41,41], notes: "`applySpec` takes an object shape with functions."},
      { range: [41,46], notes: "The input value will be passed to each of these functions..."},
      { range: [41,46], notes: "...and the output will be an object of the same shape!"},
  ]}
/>

---

```js
`C4@16n E4@16n G4@16n C5@16n E5@16n G4@16n C5@16n E5@16n`
```
This input string becomes...

---

```js
[ 
  "C4@16n", "E4@16n", "G4@16n", "C5@16n",
  "E5@16n", "G4@16n", "C5@16n", "E5@16n", 
]
```
...this array of strings, which becomes...

---

```js
[
  { "name": "C", "octave": 4, "length": "16n", "time": 0 },
  { "name": "E", "octave": 4, "length": "16n", "time": 0.125 },
  { "name": "G", "octave": 4, "length": "16n", "time": 0.25 },
  { "name": "C", "octave": 5, "length": "16n", "time": 0.375 },
  { "name": "E", "octave": 5, "length": "16n", "time": 0.5 },
  { "name": "G", "octave": 4, "length": "16n", "time": 0.625 },
  { "name": "C", "octave": 5, "length": "16n", "time": 0.75 },
  { "name": "E", "octave": 5, "length": "16n", "time": 0.875 }
]
```
...this array of note objects!

---

# TODO: show prelude "score"

---

# TODO: prelude example
<Wow />
---

# TODO: show mario "score"

---

# TODO: mario example
<Wow />

---

# Why?

- Forces you to bring down problems into their smallest parts
 - Helps with reasonability
 - Helps with testing
 - If necessary, helps with parallelization

---

